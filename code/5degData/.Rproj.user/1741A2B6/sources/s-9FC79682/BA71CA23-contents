## Preliminaries
#rm(list=ls())
library(INLA)
library(maps)
library(excursions)
library(fields)

set.seed(101)
robjDir <- "/nr/project/stat/ClimateLRM/GitHub/Ola/TemperatureTrends/code/R/Robj/"

#########################################################################################
## Load data object
##   'data.inla' is a data frame with S.org*n.year rows:
##        S.org=1571 measurement locations
##        n.year=65 annual time points regularized to [0,1] via t'=(t-1)/(n.year-1)
##    and 5 columns:
##        t.vec:  Time (=rep(t',each=S))
##        y.vec:  Temperatures (in degC)
##        lon.vec: Longitudes of measurement location (repeatedly)
##        lat.vec: Latitudes of measurement location (repeatedly)
##        station.id: Indices for the different measurement locations (=rep(1:S,n.year))
#season <- "DJF"
season <- "JJA"

load(file=paste0(robjDir,season,"_data.agg.5deg.RData"))
data.agg.org <- data.agg

n.year <- dim(data.agg$y)[1]
S <- dim(data.agg$y)[2]

data.inla <- data.frame(t.vec=as.vector(t(data.agg$t)),
                        y.vec=as.vector(t(data.agg$y)),
                        lon.vec=rep(data.agg$lon,n.year),
                        lat.vec=rep(data.agg$lat,n.year),
                        station.id=rep(1:S,n.year),
                        time=rep(1:n.year,each=S))


## 2017-10-13, HAU: Centering time variable to correspond to a non-intercept model of the anomalies.
##                  Necessary since the non-intercept model gets the slope wrong if the x axis starts at t=0 
##                  Rather, the y-value at t=0.5 should be translated to t=0 (can be obtained by allowing for an intercept in the model),
##                  alternatively by translating the x-axis so that the mean x-value corresponds to t=0 (t.new=t-mean(t)).
#data.inla$t.vec <- (data.inla$t.vec-t.min)/(t.max-t.min)
t.min <- min(data.inla$t.vec)
t.max <- max(data.inla$t.vec)
data.inla$t.vec <- (data.inla$t.vec-t.min)/(t.max-t.min)
data.inla$t.vec <- data.inla$t.vec-mean(data.inla$t.vec)
data.inla$t.vec <- data.inla$t.vec*(n.year/10)          # leaves estimated trend as degC/decade


#########################################################################################
## For each location, convert original scale temperatures into (standardized) anomalies
## Consequently, global spatiotemporal mean equals zero as well
data.inla.unscaled <- data.inla
station.ids <- unique(data.inla$station.id)
y.stations <- NULL
y.stations.org <- NULL
for (i in 1:length(station.ids)) {
  y.loc <- data.inla[data.inla$station.id==station.ids[i],]$y.vec
  #y.anomaly <- as.vector(scale(y.loc,center=TRUE,scale=FALSE))               # mean-centered anomalies
  y.anomaly <- as.vector(scale(y.loc,center=TRUE,scale=TRUE))                 # mean-centered and standardized anomalies
  data.inla[data.inla$station.id==station.ids[i],]$y.vec <- y.anomaly
  y.stations <- cbind(y.stations,y.anomaly)
  y.stations.org <- cbind(y.stations.org,y.loc)
}

## Scale covariates by their column means and standard deviations (globally)
## Alternatively, also scale the response (local temperature anomalies)????
if (0) {
  mean.covariates <- apply(data.inla[,c(1,3,4)],2,mean)
  sd.covariates <- apply(data.inla[,c(1,3,4)],2,sd)
  data.inla[,c(1,3,4)] <- scale(data.inla[,c(1,3,4)],center=mean.covariates,scale=sd.covariates)
}
#mean.covariates <- apply(data.inla[,c(1:4)],2,mean)
#sd.covariates <- apply(data.inla[,c(1:4)],2,sd)
#data.inla[,c(1:4)] <- scale(data.inla[,c(1:4)],center=mean.covariates,scale=sd.covariates)



#########################################################################################
##
## M O D E L   F I T T I N G   V I A   I N L A
##
#########################################################################################


#########################################################################################
## INLA mesh
lon.vec <- data.inla$lon.vec[1:S]
lat.vec <- data.inla$lat.vec[1:S]
coords <- cbind(lon.vec,lat.vec)
if(0) {
mesh <- inla.mesh.2d(loc=coords,
                     offset=c(3,6),
                     max.edge=c(10,20),
                     min.angle=c(21,21))
}
if (0) {
mesh <- inla.mesh.2d(loc=coords,
#                     loc.domain=borders,
                     offset=c(3,6),
                     max.edge=c(100,200),
                     min.angle=c(26,26),
#                     cutoff=0,
                     plot.delay=2)
}
if (0) {
  #bnd <- inla.nonconvex.hull(coords,convex=50)
  mesh <- inla.mesh.2d(loc=coords,
                       offset=c(5,20),
                       cutoff=5,
                       #                     boundary=bnd,
                       max.edge=c(10,50),
                       min.angle=c(26,21))
}
if (0) {
  #bnd <- inla.nonconvex.hull(coords,convex=50)
  mesh <- inla.mesh.2d(loc=coords,
                       offset=c(5,10),
                       cutoff=4.1,
                       #                       boundary=bnd,
                       max.edge=c(5,10),
                       min.angle=c(26,21)
  )
}
par(mfrow=c(1,1))
#par(mfrow=c(2,2))
if (1) {
  #bnd <- inla.nonconvex.hull(coords,convex=50)
  mesh <- inla.mesh.2d(loc=coords,
                       offset=c(7.5,15),
                       #cutoff=4.5,
                       #                       boundary=bnd,
                       max.edge=c(10,10), # OPTIMAL: c(5,10)=>mesh$n=511, c(10,10)=>mesh$n=203
                       min.angle=c(21,21)
  )
}                     #good compromise(?), 711 mesh points
if (0) {
  #bnd <- inla.nonconvex.hull(coords,convex=50)
  mesh <- inla.mesh.2d(loc=coords,
                       offset=c(7.5,15),
                       cutoff=5,    # OPTIMAL: 4=>mesh$n=244, 4.5=>mesh$n=216, 5=>mesh$n=175
                       #                       boundary=bnd,
                       max.edge=c(5,10), # OPTIMAL: c(5,10)
                       min.angle=c(21,21)
  )
}                     #good compromise(?), 711 mesh points

(mesh$n)              # =175
(nrow(unique(mesh$loc[mesh$idx$loc,1:2]))/nrow(coords))
#mesh$idx$loc
plot(mesh$loc[,1:2], col="gray30",main=paste0("5deg data, ",mesh$n," mesh points"))
map("world",xlim=c(-20,50), ylim=c(15,80),col="gray45",fill=TRUE,add=TRUE)
#map("world",xlim=c(-30,60), ylim=c(15,95),col="gray45",fill=fillworld,add=TRUE)
#map("world",xlim=range(lon.vec), ylim=range(lat.vec),col="gray45",fill=TRUE,add=TRUE)
plot(mesh, col="gray30", add=TRUE)
points(coords, col=2, pch=16, cex=0.6)
points(mesh$loc[mesh$idx$loc,1:2], col=3, pch=16, cex=0.95)
#points(loc.pred, col=4, pch=16, cex=0.6)


#########################################################################################
## SPDE model with Matérn covariance structure
## Possible extension: Specify PC priors for the Matérn fields parameters...
#spde <- inla.spde2.matern(mesh, alpha=2, theta.prior.prec=1.5, constr=TRUE)
#spde <- inla.spde2.matern(mesh, alpha=2, theta.prior.prec=1.5, constr=FALSE)
#spde <- inla.spde2.pcmatern(mesh, alpha=2,prior.range=c(10,0.5), prior.sigma=c(1,0.01), constr=FALSE)
spde <- inla.spde2.pcmatern(mesh, alpha=2,prior.range=c(20,0.5), prior.sigma=c(1,0.01), constr=FALSE)


#########################################################################################
## Problem formulation using a 'stack' data structure in INLA
## For construction details, see eg 'stack.est' on page 23 of https://inla.googlecode.com/hg/r-inla.org/case-studies/Blangiardo-et-al-2012/Report-version-Oct-2012.pdf
#########################################################################################

#########################################################################################
## Projection from SPDE mesh to an output grid in measurement space used for results, incl excursion sets
lon.prd <- c(-12,44)
lat.prd <- c(34,72)
#lon.prd <- c(-10,36)
#lat.prd <- c(40,71)
#stepsize <- 25*1/111    # Approximately 25km square grid cells
#stepsize <- 1/4         # Approximately 0.25deg lon/lat square grid cells, matching the E-OBS grid resolution
stepsize <- 1         # Approximately 1deg lon/lat square grid cells, matching the E-OBS grid resolution
nxy <- round(c(diff(range(lon.prd)),diff(range(lat.prd)))/stepsize)
lattice.prd <- inla.mesh.projector(mesh,xlim=range(lon.prd),ylim=range(lat.prd), dims=nxy+1)
lattice.prd.mesh <- submesh.grid(matrix(1,nxy[1]+1,nxy[2]+1),list(loc=lattice.prd$lattice$loc,dims=nxy+1))


#########################################################################################
## Projector matrices of various field components of the SPDE model

## tau field; AR(1) temporal correlation with no covariance in space
## xi field; Spatial covariance structure a la Matérn, no temporal correlation
A.proj.tau <- inla.spde.make.A(mesh,
                               loc=as.matrix(cbind(rep(coords[,1],n.year),rep(coords[,2],n.year))),
                               group=data.inla$time,
                               n.group=n.year)
                          
## Dynamic regression field; purely spatial coefficients of a trend component (additional to a linear term)
## OBS!! Of the below projector matrices, A.proj.alpha1s.repl and A.proj.alpha1s.group are both identical
##       and hold 6565 (mesh$n x n.year) columns. A.proj.alpha1s holds 101 (mesh$n) columns.
##       I am not sure which gives the correct formulation for our problem: For this part, I consider we have observations
##       in each location for different values of a covariate 't.vec' (identical values for all locations)
##       without imposing any time series structure.
A.proj.alpha1s <- inla.spde.make.A(mesh,
                                   loc=as.matrix(cbind(rep(lon.vec,n.year),rep(lat.vec,n.year))),
                                   weights=data.inla$t.vec)         # NB! t.vec scaled to be in [-0.5,0.5]

## Dynamic regression field on prediction lattice locations in observation space
##   dim(A.prd) = 580 x 175 (= (nxy[1]+1)*(nxy[2]+1) x spde$n.spde)
#A.prd <- inla.spde.make.A(mesh,loc=lattice.prd$lattice$loc)
A.prd <- inla.spde.make.A(mesh,loc=lattice.prd.mesh$loc)


#########################################################################################
## Spatial indices of various field components of the SPDE model
ind.tau <- inla.spde.make.index(name="field.tau",n.spde=spde$n.spde,n.group=n.year)
ind.alpha1s <- inla.spde.make.index(name="field.alpha1s",n.spde=spde$n.spde)


#########################################################################################
## Fit increasingly complex INLA models; our ultimate aim is model D
##
##    Model A: Fixed effect only (global trend)
##    Model B: No trend. Separable temporal and spatial temperature effect (along the 
##             lines of Piemonte air pollution example in Sec. 7.2 of Blangiardo & 
##             Cameletti, Wiley 2015 (B&C))
##    Model C: Extending model A to also include a spatially varying trend field. 
##             Formulation inspired by B&C (Secs. 6.8 and 6.10) and examples dynamic
##             regression in the R-INLA tutorial on SPDE models (Sec. 5.5 in the 
##             March 2 2017 edition of the document)
##    Model D: Combining models B and C by including two separate fields in the stack
##             construction


#########################################################################################
## Model A: g_s(t) = alpha_1 * t
if (0) {
  ## Stack data structure
  stack.est.A <- inla.stack(data=list(y=data.inla$y.vec),
                            A=list(1),
                            effects=list(list(trend=data.inla$t.vec)),
                            tag="est.A")
  stack.A <- inla.stack(stack.est.A)
  
  ## INLA formula
  formula.A <- y ~ -1 + trend
  
  ## Run INLA
  tA.time <- system.time(result.A <- inla(formula.A,
                                          data=inla.stack.data(stack.A,spde=spde),
                                          family="gaussian",
                                          verbose=TRUE,
                                          #control.family=list(hyper=list(prec=list(initial=10,fixed=TRUE))),
                                          control.compute=list(config=TRUE),
                                          control.predictor=list(A=inla.stack.A(stack.A),compute=TRUE),
                                          control.inla=list(int.strategy="eb")))
}


#########################################################################################
## Model B: g_s(t) = tau_ts
##          tau_ts = a * tau_(t-1)s + xi_ts  (ie AR(1) in time)
##          xi_ts ~ N(0,Sigma_xi^2)          (ie Matern in space)
if (0) {
  ## Stack data structure
  stack.est.B <- inla.stack(data=list(y=data.inla$y.vec),
                            A=list(A.proj.tau),
                            effects=list(ind.tau),
                            tag="est.B")
  stack.B <- inla.stack(stack.est.B)
  
  ## INLA formula
  #formula.B <- y ~ -1 + f(field.tau,model=spde,group=field.tau.group,control.group=list(model="ar1"),constr=FALSE)
  formula.B <- y ~ -1 + f(field.tau,model=spde,group=field.tau.group,control.group=list(model="ar1"))
  
  ## Run INLA
  tB.time <- system.time(result.B <- inla(formula.B,
                                          data=inla.stack.data(stack.B,spde=spde),
                                          family="gaussian",
                                          verbose=TRUE,
                                          control.family=list(hyper=list(prec=list(initial=10,fixed=TRUE))),
                                          control.compute=list(config=TRUE),
                                          control.predictor=list(A=inla.stack.A(stack.B),compute=TRUE),
                                          control.inla=list(int.strategy="eb")))
}


#########################################################################################
## Model C: g_s(t) = (alpha_1 + alpha_1s) * t
##          tau_ts = 0
if (0) {
  ## Stack data structure
  stack.est.C <- inla.stack(data=list(y=data.inla$y.vec),
                            A=list(A.proj.alpha1s,1),
                            effects=list(ind.alpha1s,list(trend=data.inla$t.vec)),
                            tag="est.C")
  
  #stack.C <- inla.stack(stack.est.C,stack.pred.C)
  #stack.C <- inla.stack(stack.est.C,stack.exc.C)
  stack.C <- inla.stack(stack.est.C)
  #stack.C.repl <- inla.stack(stack.est.C.repl)
  #stack.C.group <- inla.stack(stack.est.C.group)
  
  ## INLA formula
  #formula.C <- y ~ -1 + trend + f(field.alpha1s,model=spde,constr=FALSE)
  formula.C <- y ~ -1 + trend + f(field.alpha1s,model=spde)
  
  ## Run INLA
  tC.time <- system.time(result.C <- inla(formula.C,
                                          data=inla.stack.data(stack.C,spde=spde),
                                          family="gaussian",
                                          verbose=TRUE,
                                          control.family=list(hyper=list(prec=list(initial=10,fixed=TRUE))),
                                          control.compute=list(config=TRUE),
                                          control.predictor=list(A=inla.stack.A(stack.C),compute=TRUE),
                                          control.inla=list(int.strategy="eb")))
  #result.C.repl <- inla(formula.C,
  #                      data=inla.stack.data(stack.C.repl,spde=spde),
  #                      family="gaussian",
  #                      verbose=TRUE,
  #                      control.family=list(hyper=list(prec=list(initial=10,fixed=TRUE))),
  #                      control.compute=list(config=TRUE),
  #                      control.predictor=list(A=inla.stack.A(stack.C.repl),compute=TRUE),
  #                      control.inla=list(int.strategy="eb"))
  #result.C.group <- inla(formula.C,
  #                       data=inla.stack.data(stack.C.group,spde=spde),
  #                       family="gaussian",
  #                       verbose=TRUE,
  #                       control.family=list(hyper=list(prec=list(initial=10,fixed=TRUE))),
  #                       control.compute=list(config=TRUE),
  #                       control.predictor=list(A=inla.stack.A(stack.C.group),compute=TRUE),
  #                       control.inla=list(int.strategy="eb"))
  
}


#########################################################################################
## Model D: g_s(t) = (alpha_1 + alpha_1s) * t  +  tau_ts   (alpha_1s Matern in space, no temporal correlation)
##          tau_ts = a * tau_(t-1)s + xi_ts  (ie AR(1) in time)
##          xi_ts ~ N(0,Sigma_xi^2)          (ie Matern in space)
stack.est.D <- inla.stack(data=list(y=data.inla$y.vec),
                          A=list(A.proj.tau,A.proj.alpha1s,1),
                          effects=list(ind.tau,ind.alpha1s,list(trend=data.inla$t.vec)),
                          tag="est.D")

## Prediction stack for alpha.1 + alpha.1s (global fixed effect + spatial coefficient field)
#  Prediction onto mesh in INLA space, mesh$n locations
stack.prd.mesh.D <- inla.stack(data=list(y=NA),
                               A=list(1,1),
                               #                               effects=list(ind.alpha1s,list(trend=rep(1.2366,mesh$n))),
                               effects=list(ind.alpha1s,list(trend=rep(1,mesh$n))),   #setter verdien 1 på *variabelen* trend??? 
                               tag="prd.mesh.D")                                      #eller setter alpha.1=1, dvs koeffisientverdien?
#  Prediction onto lattice in E-OBS space, 29 x 20 = 580 locations
stack.prd.lattice.D <- inla.stack(data=list(y=NA),
                                  A=list(A.prd,1),
                                  #                                  effects=list(ind.alpha1s,list(trend=rep(1.2366,lattice.prd.mesh$n))),
                                  effects=list(ind.alpha1s,list(trend=rep(1,lattice.prd.mesh$n))),
                                  tag="prd.lattice.D")

## Full stack for estimation and prediction
stack.D <- inla.stack(stack.est.D,stack.prd.mesh.D,stack.prd.lattice.D)


## INLA formula
## OBS! *** TO BE CHECKED ***:
##      Spatially varying covariate coefficients:
##         constr=F (or else we would force the covariate to have, on average, zero effect).
##      For standard spatial fields, we would rather use constr=TRUE IF we include also a mean
##      effect in the model. See eg http://www.r-inla.org/comments-1 (search for 'constr effect zero',
##      leading to two hits: 16.04.14 av Daniel Simpson and 14.12.15 av TDM)
##      However: Now that we are using anomalies, what is the correct 'constr' setting...?

#formula.D <- y ~ -1 + trend + f(field.alpha1s,model=spde,constr=FALSE) + f(field.tau,model=spde,group=field.tau.group,control.group=list(model="ar1"),constr=FALSE)
formula.D <- y ~ -1 + trend + f(field.alpha1s,model=spde) + 
                              f(field.tau,model=spde,group=field.tau.group,control.group=list(model="ar1"))
#formula.D <- y ~ -1 + trend + f(field.alpha1s,model=spde) + 
                              f(field.tau,model=spde,group=field.tau.group,control.group=list(model="ar1",hyper=list(rho=list(prior="pc.cor0"),theta1=list(prior="pc.prec"))))

## Run INLA
tD.time <- system.time(result.D <- inla(formula.D,
                                        data=inla.stack.data(stack.D,spde=spde),
                                        family="gaussian",
                                        verbose=TRUE,
                                        control.family=list(hyper=list(prec=list(initial=10,fixed=TRUE))),
                                        control.compute=list(config=TRUE),
                                        control.predictor=list(A=inla.stack.A(stack.D),compute=TRUE),
                                        control.inla=list(int.strategy="eb")))


############################################################################
##
## S A V E   F I T T E D   M O D E L S
##
############################################################################

save(coords,
     mesh,
     spde,
     lon.prd,lat.prd,
     lattice.prd.mesh,
     stack.D,
     result.D,
     tD.time,
     data.inla,
     y.stations,
     file=paste0(robjDir,season,"_PCpri.models5deg.noconstraints.decade.",mesh$n,".RData"))
     #file=paste0(robjDir,season,"_models5deg.noconstraints.decade.",mesh$n,".RData"))
#save(result.D,data.inla,y.stations,y.stations.org,coords,mesh,file=paste0(robjDir,season,"_models5deg.noconstraints.decade.RData"))
#save(result.A,result.B,result.C,result.D,data.inla,y.stations,y.stations.org,coords,mesh,file=paste0(robjDir,season,"_models1deg.noconstraints.RData"))
#save(result.A,result.D,data.inla,y.stations,y.stations.org,coords,mesh#' Transform x and y (e.g. points from Cartesian system) to polar coordinates
