## Preliminaries
rm(list=ls())
library(nlme)
library(INLA)
library(maps)
library(excursions)
library(fields)
library(RColorBrewer)
library(grid)
source("plotSeaMask.R")
source("defineColorbar.R")

set.seed(101)

#########################################################################################
## R data object files corresponding to 5 x 5 degrees resolution
##   The original data holds mean JJA E-OBS temperature over Europe for S=70 locations
##   and n.year=65 years.
##   Each object file contains the following objects:
##      coords
##      mesh
##      spde
##      lon.prd,lat.prd
##      lattice.prd.mesh
##      stack.D
##      result.D
##      tD.time
##      data.inla
##      y.stations

## Preliminaries
dataDir <- "../../../data/"
input.files.default <- c("JJA_models5deg.noconstraints.decade.203.RData",
                         "JJA_models1deg.noconstraints.decade.711.RData",
                         "JJA_models0pt5deg.Iberia.noconstraints.decade.430.RData",
                         "JJA_models0pt5deg.NoSwFi.noconstraints.decade.1153.RData")
input.files <- paste0(dataDir,input.files.default)

## Plot resolution
plotPDF <- TRUE
#plotPDF.individual <- TRUE
plotPDF.individual <- FALSE
plotPDF.onefile <- !plotPDF.individual
plt.axes <- plotPDF.onefile
num.res <- c(5,1,0.5,0.5)
resolution <- paste0(num.res,"deg",c(rep("",2),"Iberia","NoSwFi"))
coords.all <- list()
mesh.all <- list()
marg.hyperpar.all <- list()
field.trend.variance <- list()
field.trend.range <- list()
field.noise.variance <- list()
field.noise.range <- list()
ar1.phi <- list()
marg.significant005.all <- list()
marg.significant001.all <- list()
marg.significant005bonf.all <- list()
marg.significant001bonf.all <- list()
lattice.prd.mesh.all <- list()
fit.gls <- list()
idx.mesh <- list()
exc.mesh <- list()
exc.lattice <- list()
lon.prd.all <- list()
lat.prd.all <- list()
lon.prd.all[[1]] <- c(-12,41.6)
lat.prd.all[[1]] <- c(35.2,72)
lon.prd.all[[2]] <- c(-12,41.6)
lat.prd.all[[2]] <- c(35.2,72)
lon.prd.all[[3]] <- c(-12,6)
lat.prd.all[[3]] <- c(35.6,45.2)
lon.prd.all[[4]] <- c(2,32.6)
lat.prd.all[[4]] <- c(54.2,72)
probs <- list()
probs[[1]] <- c(0.05,0.01)
probs[[2]] <- c(0.05,0.01)
probs[[3]] <- c(0.05,0.01)
probs[[4]] <- c(0.05)
#probs[[5]] <- c(0.05,0.01)
#probs[[6]] <- c(0.05,0.01)
lon.plt.all <- list()
lon.plt.all[[1]] <- c(-18,48)
lon.plt.all[[2]] <- c(-18,48)
lon.plt.all[[3]] <- c(-30,10)
lon.plt.all[[4]] <- c(-1,38)
lat.plt.all <- list()
lat.plt.all[[1]] <- c(25,80)
lat.plt.all[[2]] <- c(25,80)
lat.plt.all[[3]] <- c(30,48)
lat.plt.all[[4]] <- c(49,78)

###########################################################################################
## Loop over files and prepare objects necessary for plotting
#for (ifil in 1:length(input.files)) {
for (ifil in 1:1) {
    
  ## Load object file
  load(file=input.files[ifil])
  S <- length(unique(data.inla$station.id))
  n.year <- length(unique(data.inla$time))

  lon.prd <- lon.prd.all[[ifil]]
  lat.prd <- lat.prd.all[[ifil]]

  #########################################################################################
  ## Pointwise fitting of a linear regression with AR(1) noise using nlme::gls()
  coeff.all <- NULL
  for (j in 1:S) {
    data.tmp <- data.frame(yy=y.stations[,j],tt=unique(sort(data.inla$t.vec)))
    gls.reg.ar1 <- nlme::gls(yy ~ -1+tt, data=data.tmp,correlation=corAR1(form=~1))
    coeff.ar1 <- (summary(gls.reg.ar1))$tTable
    coeff.all <- rbind(coeff.all,as.vector(coeff.ar1))
  }
  fit.gls[[ifil]] <- as.data.frame(coeff.all)
  names(fit.gls[[ifil]]) <- dimnames(coeff.ar1)[[2]]
                                  
  #########################################################################################
  ## Marginal posteriors of trend field (alpha1+alpha1.s) on lattice
  
  
  #########################################################################################
  ## Hyperparameter marginal posteriors
  marg.hyperpar.all[[ifil]] <- result.D$marginals.hyperpar

  #Transfer internal hyperparameters theta1 and theta2 and extract variance and range
  res.transf.trend <- inla.spde2.result(result.D,"field.alpha1s",spde,do.transform=TRUE)
  field.trend.variance[[ifil]] <- res.transf.trend$marginals.variance.nominal[[1]]
  field.trend.range[[ifil]] <- res.transf.trend$marginals.range.nominal[[1]]
  res.transf.noise <- inla.spde2.result(result.D,"field.tau",spde,do.transform=TRUE)
  field.noise.variance[[ifil]] <- res.transf.noise$marginals.variance.nominal[[1]]
  field.noise.range[[ifil]] <- res.transf.noise$marginals.range.nominal[[1]]
  ar1.phi[[ifil]] <- result.D$marginals.hyperpar$`GroupRho for field.tau`
  
  
  #########################################################################################
  ## INLA mesh and lattice
  coords.all[[ifil]] <- coords
  mesh.all[[ifil]] <- mesh
  lattice.prd.mesh.all[[ifil]] <- lattice.prd.mesh
  
  ## Harmonize mesh and lattice extent for plotting
  idx.lat <- (lat.prd[1]<=mesh$loc[,2]&mesh$loc[,2]<lat.prd[2])
  idx.lon <- (lon.prd[1]<=mesh$loc[,1]&mesh$loc[,1]<lon.prd[2])
  idx.mesh[[ifil]] <- idx.lat*idx.lon
  

  ##########################################################################################################
  ## Calculate excursions: Level u avoidance sets
  u.curr=0

  # INLA space (mesh)
  exc.mesh[[ifil]] <- excursions.inla(result.D,stack.D,tag="prd.mesh.D",u=u.curr,u.link=TRUE,type="!=",F.lim=0.6,method='QC')

  # Observation space (lattice.prd.mesh)
  exc.lattice[[ifil]] <- excursions.inla(result.D,stack.D,tag="prd.lattice.D",u=u.curr,u.link=TRUE,type="!=",F.lim=0.6,method='QC')

}
#save(field.trend.variance,field.trend.range,field.noise.variance,field.noise.range,ar1.phi,file=paste0(dataDir,"postMargHyper.RData"))


##########################################################################################################
##
## P L O T T I N G
##
##########################################################################################################

if (plotPDF & plotPDF.onefile) pdf(file="results_allInOne.pdf",paper="a4r")

##############################################################################################################
## Posterior mean and stdev trend ranges across resolutions and meshes/lattices
zz <- NULL
zz.std <- NULL
#for (ifil in 1:length(input.files)) {
for (ifil in 1:1) {
    zz <- range(zz,c(exc.mesh[[ifil]]$mean[idx.mesh[[ifil]]==TRUE],
                   exc.lattice[[ifil]]$mean,
                   fit.gls[[ifil]]$Value))
  zz.std <- range(zz.std,c(sqrt(exc.mesh[[ifil]]$vars[idx.mesh[[ifil]]==TRUE]),
                           sqrt(exc.lattice[[ifil]]$vars),
                           fit.gls[[ifil]]$'Std.Error'))
}
rr <- c(-max(abs(zz)),max(abs(zz)))

##############################################################################################################
## Palettes
cmap <- colorRampPalette(brewer.pal(9, "YlGnBu"))(100)
cmap.F <- colorRampPalette(brewer.pal(9, "Greens"))(100)
cmap.RdBu <- rev(colorRampPalette(brewer.pal(9, "RdBu"))(100))
cmap.rwb <- defineColorbar(z=zz,rr=rr,set_white=0,col_scheme="bwr")
cmap.rwb.mean <- cmap.rwb$color
brk <- cmap.rwb$brk
brk.at <- cmap.rwb$brk.at
brk.lab <- cmap.rwb$brk.lab

ColorLevels <- seq(rr[1],rr[2],length=length(cmap.rwb.mean))
ColorLevels.std <- seq(zz.std[1],zz.std[2],length=length(cmap.F))


##############################################################################################################
## Loop over files and prepare various plots
##############################################################################################################

#for (ifil in 1:length(input.files)) {
for (ifil in 1:1) {
    
  ## Number of lon/lat grid cells
  n.lon.data <- ceiling(diff(range(mesh.all[[ifil]]$loc[idx.mesh[[ifil]]==TRUE,1]))/num.res[ifil])
  n.lat.data <- ceiling(diff(range(mesh.all[[ifil]]$loc[idx.mesh[[ifil]]==TRUE,2]))/num.res[ifil])
  n.lon.lattice <- ceiling(diff(range(mesh.all[[ifil]]$loc[idx.mesh[[ifil]]==TRUE,1]))/1)
  n.lat.lattice <- ceiling(diff(range(mesh.all[[ifil]]$loc[idx.mesh[[ifil]]==TRUE,2]))/1)

  ## Which mesh points correspond to data points
  id.plot <- mesh.all[[ifil]]$idx$loc
  lon.offset <- 2
  lat.offset <- 2
  lon.max <- max(mesh.all[[ifil]]$loc[id.plot,1])+lon.offset
  lon.min <- min(mesh.all[[ifil]]$loc[id.plot,1])-lon.offset
  lat.max <- max(mesh.all[[ifil]]$loc[id.plot,2])+lat.offset
  lat.min <- min(mesh.all[[ifil]]$loc[id.plot,2])-lat.offset
  ixy.mesh <- which(mesh.all[[ifil]]$loc[,1]>lon.min & 
                    mesh.all[[ifil]]$loc[,1]<lon.max &
                    mesh.all[[ifil]]$loc[,2]>lat.min & 
                    mesh.all[[ifil]]$loc[,2]<lat.max)
  ixy.lattice <- which(lattice.prd.mesh.all[[ifil]]$loc[,1]>lon.min & 
                       lattice.prd.mesh.all[[ifil]]$loc[,1]<lon.max &
                       lattice.prd.mesh.all[[ifil]]$loc[,2]>lat.min & 
                       lattice.prd.mesh.all[[ifil]]$loc[,2]<lat.max)

  ## Image matrices
  postmean.mesh <- as.image(exc.mesh[[ifil]]$mean[ixy.mesh],x=mesh.all[[ifil]]$loc[ixy.mesh,1:2],nx=n.lon.data,ny=n.lat.data)   #counting the number of mesh locations in either direction
  poststdev.mesh <- as.image(sqrt(exc.mesh[[ifil]]$vars[ixy.mesh]),x=mesh.all[[ifil]]$loc[ixy.mesh,1:2],nx=n.lon.data,ny=n.lat.data)   #counting the number of mesh locations in either direction
  postmean.lattice <- as.image(exc.lattice[[ifil]]$mean[ixy.lattice],x=lattice.prd.mesh.all[[ifil]]$loc[ixy.lattice,1:2],nx=n.lon.lattice,ny=n.lat.lattice) 
  poststdev.lattice <- as.image(sqrt(exc.lattice[[ifil]]$vars[ixy.lattice]),x=lattice.prd.mesh.all[[ifil]]$loc[ixy.lattice,1:2],nx=n.lon.lattice,ny=n.lat.lattice) 
  margsignif005.lattice <- as.image(marg.significant005.all[[ifil]][ixy.lattice],x=lattice.prd.mesh.all[[ifil]]$loc[ixy.lattice,1:2],nx=n.lon.lattice,ny=n.lat.lattice) 
  margsignif005.lattice$z[margsignif005.lattice$z>0] <- 1
  margsignif001.lattice <- as.image(marg.significant001.all[[ifil]][ixy.lattice],x=lattice.prd.mesh.all[[ifil]]$loc[ixy.lattice,1:2],nx=n.lon.lattice,ny=n.lat.lattice) 
  margsignif001.lattice$z[margsignif001.lattice$z>0] <- 1
  margsignif005.bonf.lattice <- as.image(marg.significant005bonf.all[[ifil]][ixy.lattice],x=lattice.prd.mesh.all[[ifil]]$loc[ixy.lattice,1:2],nx=n.lon.lattice,ny=n.lat.lattice) 
  margsignif005.bonf.lattice$z[margsignif005.bonf.lattice$z>0] <- 1
  margsignif001.bonf.lattice <- as.image(marg.significant001bonf.all[[ifil]][ixy.lattice],x=lattice.prd.mesh.all[[ifil]]$loc[ixy.lattice,1:2],nx=n.lon.lattice,ny=n.lat.lattice) 
  margsignif001.bonf.lattice$z[margsignif001.bonf.lattice$z>0] <- 1
  
  lon.plt <- c(lon.min,lon.max)
  lat.plt <- c(lat.min,lat.max)
  
  ## Plot mesh
  if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/mesh_",resolution[ifil],".pdf"))
  par(mfrow=c(1,1),oma=c(0,0,1,7))
  plot(mesh.all[[ifil]]$loc[,1:2], col="gray30",xlab="lon",ylab="lat")
  map("world",col="gray45",fill=TRUE,add=TRUE)
  plot(mesh.all[[ifil]], col="gray30", add=TRUE)
  points(coords.all[[ifil]], col=2, pch=16, cex=0.6)
  points(mesh.all[[ifil]]$loc[mesh.all[[ifil]]$idx$loc,1:2], col=3, pch=16, cex=0.95)
  if (!plotPDF.individual) mtext(text=paste0("INLA mesh (",resolution[ifil],"): #mesh points = ",mesh.all[[ifil]]$n),side=3,outer=TRUE,cex=1)
  if (plotPDF & plotPDF.individual) dev.off()
                              
    
  ################################################################################################################
  ## Posterior trend distribution (mean and stdev) for mesh and lattice
  ################################################################################################################

  par(mfrow=c(1,1),oma=c(0,0,1,5),cex.main=1)
  
  ################################################################################################################
  ## Mean
  
  ## INLA space (mesh)
  if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/postmean_mesh_",resolution[ifil],".pdf"))

  # Grid scale in degrees and choose kernel bandwidth to be 1.5 degrees. 
  look <- image.smooth(postmean.mesh,theta=1.5)
  to.plot <- look$z
  col.plot.min <- which.min(abs(ColorLevels-range(to.plot,na.rm=T)[1]))
  col.plot.max <- which.min(abs(ColorLevels-range(to.plot,na.rm=T)[2]))
  
  par(oma=c(0,0,0,7))
  image(look,col=cmap.rwb.mean[col.plot.min:col.plot.max],axes=plt.axes,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]]) 
  map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
  plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
  par(oma=c(0,0,1,1))
  image.plot(legend.only=TRUE,breaks=brk,at=brk.at,label=brk.lab,col=cmap.rwb.mean,legend.width=.8,legend.shrink=.90,
             axis.args=list(cex.axis=0.7),legend.args=list(text="Trend (degC/decade)",side=4,font=2,line=2,cex=.9)) 
  if (!plotPDF.individual) mtext(text=paste0("mesh (",resolution[ifil],"): Decadal trend posterior mean (alpha.1 + alpha.1s)"),side=3,outer=TRUE,cex=1)
  if (plotPDF & plotPDF.individual) dev.off()
  
  
  ## Observation space (lattice.prd.mesh)
  if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/postmean_lattice_",resolution[ifil],".pdf"))

  # Grid scale in degrees and choose kernel bandwidth to be .5 degrees. 
  look <- image.smooth(postmean.lattice,theta=.5)
  to.plot <- look$z
  col.plot.min <- which.min(abs(ColorLevels-range(to.plot,na.rm=T)[1]))
  col.plot.max <- which.min(abs(ColorLevels-range(to.plot,na.rm=T)[2]))
  
  par(oma=c(0,0,0,7))
  image(look,col=cmap.rwb.mean[col.plot.min:col.plot.max],axes=plt.axes,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]]) 
  map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
  plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
  par(oma=c(0,0,1,1))
  image.plot(legend.only=TRUE,breaks=brk,at=brk.at,label=brk.lab,col=cmap.rwb.mean,legend.width=.8,legend.shrink=.90,
             axis.args=list(cex.axis=0.7),legend.args=list(text="Trend (degC/decade)",side=4,font=2,line=2,cex=.9)) 
  if (!plotPDF.individual) mtext(text=paste0("1deg lattice (",resolution[ifil],"): Decadal trend posterior mean (alpha.1 + alpha.1s)"),side=3,outer=TRUE,cex=1)
  if (plotPDF & plotPDF.individual) dev.off()
  
  
  # Observation space (pointwise fitting)
  if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/postmean_pointwise_",resolution[ifil],".pdf"))

  # Trend coefficient values for all grid points
  to.plot <- fit.gls[[ifil]]$Value
  L <- length(to.plot)
  col.plot <- rep(NA,L)
  for (i in 1:L) col.plot[i] <- which.min(abs(ColorLevels-to.plot[i]))

  par(oma=c(0,0,0,7))
  plot(mesh.all[[ifil]]$loc[id.plot,1],mesh.all[[ifil]]$loc[id.plot,2],xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]],type="p",col=cmap.rwb.mean[col.plot],pch=16,cex=1,xlab="",ylab="",axes=plt.axes,xaxs="i",yaxs="i")
  map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=TRUE,add=TRUE)
  points(mesh.all[[ifil]]$loc[id.plot,1], mesh.all[[ifil]]$loc[id.plot,2],col=cmap.rwb.mean[col.plot],pch=16,cex=1)
  plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
  par(oma=c(0,0,1,1))
  image.plot(legend.only=TRUE,breaks=brk,at=brk.at,label=brk.lab,col=cmap.rwb.mean,legend.width=.8,legend.shrink=.90,
             axis.args=list(cex.axis=0.7),legend.args=list(text="Trend (degC/decade)",side=4,font=2,line=2,cex=.9)) 
  if (!plotPDF.individual) mtext(text=paste0("Individual data point fit (",resolution[ifil],"): Decadal trend (alpha.1)"),side=3,outer=TRUE,cex=1)
  if (plotPDF & plotPDF.individual) dev.off()
  

  ################################################################################################################
  ## StDev
  
  ## INLA space (mesh)
  if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/poststdev_mesh_",resolution[ifil],".pdf"))

  # Grid scale in degrees and choose kernel bandwidth to be 1.5 degrees. 
  look <- image.smooth(poststdev.mesh,theta=1.5)
  to.plot <- look$z
  col.plot.min <- which.min(abs(ColorLevels.std-range(to.plot,na.rm=T)[1]))
  col.plot.max <- which.min(abs(ColorLevels.std-range(to.plot,na.rm=T)[2]))
  
  par(oma=c(0,0,0,7))
  image(look,col=cmap.F[col.plot.min:col.plot.max],axes=plt.axes,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]]) 
  map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
  plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
  par(oma=c(0,0,1,1))
  image.plot(legend.only=TRUE,zlim=zz.std,col=cmap.F,legend.width=.8,legend.shrink=.90,
             axis.args=list(cex.axis=0.7),legend.args=list(text="Stdev (degC/decade)",side=4,font=2,line=2,cex=.9)) 
  if (!plotPDF.individual) mtext(text=paste0("mesh (",resolution[ifil],"): Decadal trend posterior stdev (alpha.1 + alpha.1s)"),side=3,outer=TRUE,cex=1)
  if (plotPDF & plotPDF.individual) dev.off()
  
  
  ## Observation space (lattice.prd.mesh)
  if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/poststdev_lattice_",resolution[ifil],".pdf"))

  # Grid scale in degrees and choose kernel bandwidth to be .5 degrees. 
  look <- image.smooth(poststdev.lattice,theta=.5)
  to.plot <- look$z
  col.plot.min <- which.min(abs(ColorLevels.std-range(to.plot,na.rm=T)[1]))
  col.plot.max <- which.min(abs(ColorLevels.std-range(to.plot,na.rm=T)[2]))
  
  par(oma=c(0,0,0,7))
  image(look,col=cmap.F[col.plot.min:col.plot.max],axes=plt.axes,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]]) 
  map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
  plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
  par(oma=c(0,0,1,1))
  image.plot(legend.only=TRUE,zlim=zz.std,col=cmap.F,legend.width=.8,legend.shrink=.90,
             axis.args=list(cex.axis=0.7),legend.args=list(text="Stdev (degC/decade)",side=4,font=2,line=2,cex=.9)) 
  if (!plotPDF.individual) mtext(text=paste0("1deg lattice (",resolution[ifil],"): Decadal trend posterior stdev (alpha.1 + alpha.1s)"),side=3,outer=TRUE,cex=1)
  if (plotPDF & plotPDF.individual) dev.off()
  
  
  ## Observation space (pointwise fitting)
  if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/poststdev_pointwise_",resolution[ifil],".pdf"))
  
  # Trend coefficient values for all grid points
  to.plot <- fit.gls[[ifil]]$Std.Error
  L <- length(to.plot)
  col.plot <- rep(NA,L)
  for (i in 1:L) col.plot[i] <- which.min(abs(ColorLevels.std-to.plot[i]))
  
  par(oma=c(0,0,0,7))
  plot(mesh.all[[ifil]]$loc[id.plot,1],mesh.all[[ifil]]$loc[id.plot,2],xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]],type="p",col=cmap.F[col.plot],pch=16,cex=1,xlab="",ylab="",axes=plt.axes,xaxs="i",yaxs="i")
  map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=TRUE,add=TRUE)
  points(mesh.all[[ifil]]$loc[id.plot,1], mesh.all[[ifil]]$loc[id.plot,2],col=cmap.F[col.plot],pch=16,cex=1)
  plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
  par(oma=c(0,0,1,1))
  image.plot(legend.only=TRUE,zlim=zz.std,col=cmap.F,legend.width=.8,legend.shrink=.90,
             axis.args=list(cex.axis=0.7),legend.args=list(text="Stdev (degC/decade)",side=4,font=2,line=2,cex=.9)) 
  if (!plotPDF.individual) mtext(text=paste0("Individual data point fit (",resolution[ifil],"): Decadal trend stdev (alpha.1)"),side=3,outer=TRUE,cex=1)
  if (plotPDF & plotPDF.individual) dev.off()
  

  ################################################################################################################
  ## Marginal posterior significances in observation space (lattice.prd.mesh)
  ################################################################################################################
  
  ################################################################################################################
  ## Level 5% 
  
  ## No correction for multiple testing
  if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/margsignif005_lattice_",resolution[ifil],".pdf"))
  par(oma=c(0,0,0,7))
  image(margsignif005.lattice,col=c("white","red"),axes=plt.axes,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]]) 
  map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
  plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
  par(oma=c(0,0,1,1))
  if (!plotPDF.individual) mtext(text=paste0("1deg lattice (",resolution[ifil],"): Posterior marginal trend significances 5% (alpha.1 + alpha.1s)"),side=3,outer=TRUE,cex=1)
  if (plotPDF & plotPDF.individual) dev.off()
  
  ## Bonferroni correction for multiple testing
  if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/margsignif005bonf_lattice_",resolution[ifil],".pdf"))
  par(oma=c(0,0,0,7))
  image(margsignif005.bonf.lattice,col=c("white","red"),axes=plt.axes,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]]) 
  map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
  plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
  par(oma=c(0,0,1,1))
  if (!plotPDF.individual) mtext(text=paste0("1deg lattice (",resolution[ifil],"): Bonf corr posterior marginal trend significances 5% (alpha.1 + alpha.1s)"),side=3,outer=TRUE,cex=1)
  if (plotPDF & plotPDF.individual) dev.off()
  
  ################################################################################################################
  ## Level 1% 

  ## No correction for multiple testing
  if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/margsignif001_lattice_",resolution[ifil],".pdf"))
  par(oma=c(0,0,0,7))
  image(margsignif001.lattice,col=c("white","red"),axes=plt.axes,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]]) 
  map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
  plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
  par(oma=c(0,0,1,1))
  if (!plotPDF.individual) mtext(text=paste0("1deg lattice (",resolution[ifil],"): Posterior marginal trend significances 1% (alpha.1 + alpha.1s)"),side=3,outer=TRUE,cex=1)
  if (plotPDF & plotPDF.individual) dev.off()
  
  ## Bonferroni correction for multiple testing
  if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/margsignif001bonf_lattice_",resolution[ifil],".pdf"))
  par(oma=c(0,0,0,7))
  image(margsignif001.bonf.lattice,col=c("white","red"),axes=plt.axes,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]]) 
  map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
  plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
  par(oma=c(0,0,1,1))
  if (!plotPDF.individual) mtext(text=paste0("1deg lattice (",resolution[ifil],"): Bonf corr posterior marginal trend significances 1% (alpha.1 + alpha.1s)"),side=3,outer=TRUE,cex=1)
  if (plotPDF & plotPDF.individual) dev.off()
  
  
  
  ################################################################################################################
  ## Excursion sets and excursion function
  ################################################################################################################
  
  ################################################################################################################
  ## Loop over different error probabilities
  for (err.prob in probs[[ifil]]) {
  
    alpha.str <- paste0(substr(err.prob,1,1),substr(err.prob,3,4))
    
    ## Excursion sets
    sets.mesh <- continuous(exc.mesh[[ifil]],mesh.all[[ifil]],alpha=err.prob)
    sets.lattice <- continuous(exc.lattice[[ifil]],lattice.prd.mesh.all[[ifil]],alpha=err.prob)
  
    
    ##############################################################################################################
    ## Excursions: Level u avoidance sets (mesh & lattice)

    ## mesh
    if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/excursionsets_mesh_",resolution[ifil],"_",alpha.str,".pdf"))
    par(oma=c(0,0,0,7))
    plot(sets.mesh$M["1"], col = "red", main=paste0("mesh (",resolution[ifil],"): Avoidance excursion set, u=",u.curr),xpd=FALSE,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]],axes=plt.axes,xaxs="i",yaxs="i")
    map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
    plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
    if (!plotPDF.individual) mtext(text=paste0("alpha=",format(err.prob,2)),side=3,outer=FALSE,cex=1)
    if (plotPDF & plotPDF.individual) dev.off()
    
    ## lattice
    if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/excursionsets_lattice_",resolution[ifil],"_",alpha.str,".pdf"))
    par(oma=c(0,0,0,7))
    plot(sets.lattice$M["1"], col = "red", main=paste0("1deg lattice (",resolution[ifil],"): Avoidance excursion set, u=",u.curr),xpd=FALSE,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]],axes=plt.axes,xaxs="i",yaxs="i")
    map("world",xlim=lon.prd.all[[ifil]],  ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
    plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
    if (!plotPDF.individual) mtext(text=paste0("alpha=",format(err.prob,2)),side=3,outer=FALSE,cex=1)
    if (plotPDF & plotPDF.individual) dev.off()
    

    ##############################################################################################################
    ## Excursions: Interpolated contour avoidance function (mesh & lattice)
    
    if (err.prob==probs[[ifil]][1]) {
        
      ## mesh
      proj.mesh <- inla.mesh.projector(sets.mesh$F.geometry,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]], dims = c(300,200))
      if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/excursionfunction_mesh_",resolution[ifil],".pdf"))
      par(oma=c(0,0,0,7))
      image(proj.mesh$x, proj.mesh$y, inla.mesh.project(proj.mesh, field = sets.mesh$F),zlim=c(0,1),col=cmap.F, axes=plt.axes,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]], 
            main=paste0("mesh (",resolution[ifil],"): Level u=",u.curr," avoidance excursion function"),xlab="", ylab="")
      map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
      plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
      if (!plotPDF.individual) mtext(text=paste0("mesh"),side=3,outer=FALSE,cex=1)
      par(oma=c(0,0,1,1))
      image.plot(legend.only=TRUE,zlim=c(0,1),col=cmap.F,legend.width=.8,legend.shrink=.90,
                 axis.args=list(cex.axis=0.7),legend.args=list(text="",side=4,font=2,line=2,cex=.9)) 
      if (plotPDF & plotPDF.individual) dev.off()
      
      ## lattice
      proj.lattice <- inla.mesh.projector(sets.lattice$F.geometry,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]], dims = c(300,200))
      if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/excursionfunction_lattice_",resolution[ifil],".pdf"))
      par(oma=c(0,0,0,7))
      image(proj.lattice$x, proj.lattice$y, inla.mesh.project(proj.lattice, field = sets.lattice$F),zlim=c(0,1),col=cmap.F, axes=plt.axes,xlim=lon.prd.all[[ifil]],ylim=lat.prd.all[[ifil]], 
            main=paste0("1deg lattice (",resolution[ifil],"): Level u=",u.curr," avoidance excursion function"),xlab = "", ylab = "")
      map("world",xlim=lon.prd.all[[ifil]], ylim=lat.prd.all[[ifil]],col="gray45",fill=FALSE,add=TRUE)
      plotSeaMask(x.lim=lon.plt.all[[ifil]],y.lim=lat.plt.all[[ifil]],l.force='e',plotornot=FALSE)
      if (!plotPDF.individual) mtext(text=paste0("1deg lattice"),side=3,outer=FALSE,cex=1)
      par(oma=c(0,0,1,1))
      image.plot(legend.only=TRUE,zlim=c(0,1),col=cmap.F,legend.width=.8,legend.shrink=.90,
                 axis.args=list(cex.axis=0.7),legend.args=list(text="",side=4,font=2,line=2,cex=.9)) 
      if (plotPDF & plotPDF.individual) dev.off()
    }

  }

}


##############################################################################################################
## Hyperpar posterior marginals, SPDE default priors
if (plotPDF & plotPDF.individual) pdf(file=paste0("Fig/hyperpar_marginals.pdf"))
par(mfrow=c(2,3),oma=c(0,0,2,1))
for (i in 1:5) {
  xlim <- NULL
  ylim <- 0
  #for (j in 1:length(input.files.default)) {
  for (j in 1:1) {
    nn <- paste0("'",names(marg.hyperpar.all[[j]])[i],"'")
    xlim <- range(xlim,data.frame(eval(parse(text=paste0("marg.hyperpar.all[[",j,"]]$",nn))))[,1])
    ylim <- range(ylim,data.frame(eval(parse(text=paste0("marg.hyperpar.all[[",j,"]]$",nn))))[,2])
  }
  nn <- paste0("'",names(marg.hyperpar.all[[1]])[i],"'")
  plot(data.frame(eval(parse(text=paste0("marg.hyperpar.all[[",1,"]]$",nn)))),xlab=nn,type="l",lty=1,xlim=xlim,ylim=ylim)
  #for (j in 2:length(input.files.default)) {
  #  lines(data.frame(eval(parse(text=paste0("marg.hyperpar.all[[",j,"]]$",nn)))),lty=j)
  #}
}
plot(data.frame(eval(parse(text=paste0("marg.hyperpar.all[[1]]$",nn)))),type="n",lty=1,xaxt="n",yaxt="n")
legend(x=0.05,y=25,legend=resolution[1:length(input.files.default)],lty=1:length(input.files.default),cex=1,y.intersp=1)
mtext(text=paste0("Hyperparameter marginals (default priors)"),side=3,outer=TRUE,cex=1)
if (plotPDF & plotPDF.individual) dev.off()

if (plotPDF & plotPDF.onefile) dev.off()
