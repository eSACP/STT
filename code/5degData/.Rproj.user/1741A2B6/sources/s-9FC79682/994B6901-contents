## Preliminaries
#rm(list=ls())
library(INLA)
library(maps)
library(excursions)
library(fields)

set.seed(101)
dataDir <- "../../../data/"

#########################################################################################
## Load data object 'data.agg'
##   'data.agg' is a four-element list object:
##        lon: Longitudes of S=70 grid locations
##        lat: Latitudes of S=70 grid locations
##        y:   Temperatures (in degrees Celcius) at S x n.year grid locations 
##        t:   Time (in years since 1950) of temperature measurements (S x n.year matrix)

#season <- "DJF"
season <- "JJA"
load(file=paste0(dataDir,season,"_data.agg.5deg.RData"))

n.year <- dim(data.agg$y)[1]
S <- dim(data.agg$y)[2]

# Data in data.frame representation
data.inla <- data.frame(t.vec=as.vector(t(data.agg$t)),
                        y.vec=as.vector(t(data.agg$y)),
                        lon.vec=rep(data.agg$lon,n.year),
                        lat.vec=rep(data.agg$lat,n.year),
                        station.id=rep(1:S,n.year),
                        time=rep(1:n.year,each=S))


## Centering time variable to correspond to a non-intercept model of the anomalies.
## Necessary since the non-intercept model gets the slope wrong if the x axis starts at t=0 
## Rather, the y-value at t=0.5 should be translated to t=0 (can be obtained by allowing for an intercept in the model),
## alternatively by translating the x-axis so that the mean x-value corresponds to t=0 (t.new=t-mean(t)).
t.min <- min(data.inla$t.vec)
t.max <- max(data.inla$t.vec)
data.inla$t.vec <- (data.inla$t.vec-t.min)/(t.max-t.min)
data.inla$t.vec <- data.inla$t.vec-mean(data.inla$t.vec)
data.inla$t.vec <- data.inla$t.vec*(n.year/10)          # leaves estimated trend as degC/decade


#########################################################################################
## For each location, convert original scale temperatures into (standardized) anomalies
## Consequently, global spatiotemporal mean equals zero as well
data.inla.unscaled <- data.inla
station.ids <- unique(data.inla$station.id)
y.stations <- NULL
y.stations.org <- NULL
for (i in 1:length(station.ids)) {
  y.loc <- data.inla[data.inla$station.id==station.ids[i],]$y.vec
  #y.anomaly <- as.vector(scale(y.loc,center=TRUE,scale=FALSE))               # mean-centered anomalies
  y.anomaly <- as.vector(scale(y.loc,center=TRUE,scale=TRUE))                 # mean-centered and standardized anomalies
  data.inla[data.inla$station.id==station.ids[i],]$y.vec <- y.anomaly
  y.stations <- cbind(y.stations,y.anomaly)
  y.stations.org <- cbind(y.stations.org,y.loc)
}


#########################################################################################
##
## M O D E L   F I T T I N G   V I A   I N L A
##
#########################################################################################


#########################################################################################
## INLA mesh
lon.vec <- data.inla$lon.vec[1:S]
lat.vec <- data.inla$lat.vec[1:S]
coords <- cbind(lon.vec,lat.vec)
mesh <- inla.mesh.2d(loc=coords,
                     offset=c(7.5,15),
                     max.edge=c(10,10), # Alternatives: c(5,10)=>mesh$n=511, c(10,10)=>mesh$n=203
                     min.angle=c(21,21))
#Visualize mesh
if (0) {
  plot(mesh$loc[,1:2], col="gray30",main=paste0("5deg data, ",mesh$n," mesh points"))
  map("world",xlim=c(-20,50), ylim=c(15,80),col="gray45",fill=TRUE,add=TRUE)
  plot(mesh, col="gray30", add=TRUE)
  points(coords, col=2, pch=16, cex=0.6)
  points(mesh$loc[mesh$idx$loc,1:2], col=3, pch=16, cex=0.95)
}

#########################################################################################
## SPDE model with Matérn covariance structure
spde <- inla.spde2.matern(mesh, alpha=2, theta.prior.prec=1.5, constr=FALSE)


#########################################################################################
## Problem formulation using a 'stack' data structure in INLA
## For construction details, see eg 'stack.est' on page 23 of https://inla.googlecode.com/hg/r-inla.org/case-studies/Blangiardo-et-al-2012/Report-version-Oct-2012.pdf
#########################################################################################

#########################################################################################
## Projection from SPDE mesh to an output 1deg lon/lat lattice in measurement space used for results, incl excursion sets
lon.prd <- c(-12,44)
lat.prd <- c(34,72)
stepsize <- 1
nxy <- round(c(diff(range(lon.prd)),diff(range(lat.prd)))/stepsize)
lattice.prd <- inla.mesh.projector(mesh,xlim=range(lon.prd),ylim=range(lat.prd), dims=nxy+1)
lattice.prd.mesh <- submesh.grid(matrix(1,nxy[1]+1,nxy[2]+1),list(loc=lattice.prd$lattice$loc,dims=nxy+1))


#########################################################################################
## Projector matrices of various field components of the SPDE model
##    tau field: AR(1) temporal correlation with no covariance in space
##    xi field:  Spatial covariance structure a la Matérn, no temporal correlation
A.proj.tau <- inla.spde.make.A(mesh,
                               loc=as.matrix(cbind(rep(coords[,1],n.year),rep(coords[,2],n.year))),
                               group=data.inla$time,
                               n.group=n.year)
                          
## Dynamic regression field; purely spatial coefficients of a trend component (additional to a linear term)
A.proj.alpha1s <- inla.spde.make.A(mesh,
                                   loc=as.matrix(cbind(rep(lon.vec,n.year),rep(lat.vec,n.year))),
                                   weights=data.inla$t.vec)         # NB! t.vec scaled to be in [-0.5,0.5]

## Dynamic regression field on prediction lattice locations in observation space
A.prd <- inla.spde.make.A(mesh,loc=lattice.prd.mesh$loc)


#########################################################################################
## Spatial indices of various field components of the SPDE model
ind.tau <- inla.spde.make.index(name="field.tau",n.spde=spde$n.spde,n.group=n.year)
ind.alpha1s <- inla.spde.make.index(name="field.alpha1s",n.spde=spde$n.spde)


#########################################################################################
## Fit increasingly complex INLA models; our ultimate aim is model D
##
##    Model A: Fixed effect only (global trend)
##    Model B: No trend. Separable temporal and spatial temperature effect (along the 
##             lines of Piemonte air pollution example in Sec. 7.2 of Blangiardo & 
##             Cameletti, Wiley 2015 (B&C))
##    Model C: Extending model A to also include a spatially varying trend field. 
##             Formulation inspired by B&C (Secs. 6.8 and 6.10) and examples dynamic
##             regression in the R-INLA tutorial on SPDE models (Sec. 5.5 in the 
##             March 2 2017 edition of the document)
##    Model D: Combining models B and C by including two separate fields in the stack
##             construction

## Model D: g_s(t) = (alpha_1 + alpha_1s) * t  +  tau_ts   (alpha_1s Matern in space, no temporal correlation)
##          tau_ts = a * tau_(t-1)s + xi_ts  (ie AR(1) in time)
##          xi_ts ~ N(0,Sigma_xi^2)          (ie Matern in space)
stack.est.D <- inla.stack(data=list(y=data.inla$y.vec),
                          A=list(A.proj.tau,A.proj.alpha1s,1),
                          effects=list(ind.tau,ind.alpha1s,list(trend=data.inla$t.vec)),
                          tag="est.D")

## Prediction stack for alpha.1 + alpha.1s (global fixed effect + spatial coefficient field)
#  Prediction onto mesh in INLA space, mesh$n locations
stack.prd.mesh.D <- inla.stack(data=list(y=NA),
                               A=list(1,1),
                               effects=list(ind.alpha1s,list(trend=rep(1,mesh$n))),
                               tag="prd.mesh.D")
#  Prediction onto lattice in E-OBS space, 29 x 20 = 580 locations
stack.prd.lattice.D <- inla.stack(data=list(y=NA),
                                  A=list(A.prd,1),
                                  effects=list(ind.alpha1s,list(trend=rep(1,lattice.prd.mesh$n))),
                                  tag="prd.lattice.D")

## Full stack for estimation and prediction
stack.D <- inla.stack(stack.est.D,stack.prd.mesh.D,stack.prd.lattice.D)


## INLA formula
formula.D <- y ~ -1 + trend + f(field.alpha1s,model=spde) + 
                              f(field.tau,model=spde,group=field.tau.group,control.group=list(model="ar1"))

## Run INLA
tD.time <- system.time(result.D <- inla(formula.D,
                                        data=inla.stack.data(stack.D,spde=spde),
                                        family="gaussian",
                                        verbose=TRUE,
                                        control.family=list(hyper=list(prec=list(initial=10,fixed=TRUE))),
                                        control.compute=list(config=TRUE),
                                        control.predictor=list(A=inla.stack.A(stack.D),compute=TRUE),
                                        control.inla=list(int.strategy="eb")))


############################################################################
##
## S A V E   F I T T E D   M O D E L
##
############################################################################

save(coords,
     mesh,
     spde,
     lon.prd,lat.prd,
     lattice.prd.mesh,
     stack.D,
     result.D,
     tD.time,
     data.inla,
     y.stations,
     file=paste0(dataDir,season,"_models5deg.noconstraints.decade.",mesh$n,".RData"))
